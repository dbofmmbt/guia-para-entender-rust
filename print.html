<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F8EYVQDEQP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-F8EYVQDEQP');
</script>        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Book to guide developers in their Rust learning">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About the handbook</a></li><li class="chapter-item expanded affix "><li class="part-title">Guide</li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/prerequisites.html"><strong aria-hidden="true">1.1.</strong> Pre-requisites</a></li><li class="chapter-item expanded "><a href="introduction/installation.html"><strong aria-hidden="true">1.2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="introduction/hello_world.html"><strong aria-hidden="true">1.3.</strong> Hello, World!</a></li></ol></li><li class="chapter-item expanded "><a href="tools.html"><strong aria-hidden="true">2.</strong> Tools</a></li><li class="chapter-item expanded "><a href="basic_elements.html"><strong aria-hidden="true">3.</strong> Basic Elements</a></li><li class="chapter-item expanded "><a href="ownership_and_borrowing.html"><strong aria-hidden="true">4.</strong> Ownership & Borrowing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dbofmmbt/rust-handbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-handbook"><a class="header" href="#rust-handbook">Rust Handbook</a></h1>
<!-- TODO insert image -->
<p>Rust is a very well-thought programming language. It seeks to unite a variety of existing concepts from other languages, industry and academia in order to be a solid language to develop reliable and efficient solutions in a productive manner.</p>
<p>On the other hand, it gained the fame of being a language with a steep learning curve. I'm not going to fool you: Rust has a lot of resources to help you, but first you need to understand how they work. What I can tell you is that, in general, every choice made in this language has a purpose. Once you get the reasons, something which seemed complicated may become understandable.</p>
<p>If you intend to develop an application with a high degree of concurrent processing to serve a lot of HTTP requests, you'll probably need to learn about async programming (<code>async/await</code>). In case you deal directly with hardware on embedded programming, maybe you'll need to use <code>unsafe</code> to interact with the native resource of the target device. While developing a library, it may look interest to implement macros to create a more convenient interface for your users.</p>
<p>Know that you don't need to learn all of this at once, nor be a specialist on all of the language's resources. Each person can focus on those which are relevant for the fool they want to develop. Do not think that you need to absorb everything at the same time, because nobody should.</p>
<p>What I propose here is the understanding of the language. There are core concepts which every developer must know to be productive, no matter what kind of the application they do. Those are the ones I aim to teach in this material.</p>
<p>Besides that, I'll present these concepts in a specific order. Each topic is carefully designed to be based on the previous ones, forming learning layers. You shouldn't try to build the second floor of a building without building the first one, right?</p>
<p>Any concept or detail that I consider out of the scope of this handbook will have references for high-quality content available elsewhere, in order to complement this guide.</p>
<!-- TODO hook for the next section -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Start here. The idea is to prepare you for the remainder of the book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-requisites"><a class="header" href="#pre-requisites">Pre-requisites</a></h1>
<p>In general, I assume that the reader knows how to program, at least in a basic level. If I were to write a guide to teach someone to program from scratch (and I intend to do it someday!) I would explain them about computer fundamentals and programming paradigms, and that would take a while to write well. If you don't know how to program and wants to follow the guide anyway, remember to take it easy and search for additional information on the web when you feel the need.</p>
<p>Another important requisite is the alignment with my proposal. My focus is on the understanding of the concepts. In software, to understand what you're doing could be the difference between solving a problem in minutes or in days. There'll be examples and exercises throughout the guide, but my focus is always conceptual.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>The most recommended way to install Rust is by using <code>rustup</code>, which takes care of the installations and updates of the language's official tools, such as <code>rustc</code>, <code>cargo</code>, and <code>clippy</code>.</p>
<p>If you decided to install the language on your machine, just follow the instructions in the <a href="https://rustup.rs">rustup's website</a> and you'll probably be good to go. In case you use Windows, I recommend you to take a look at the <a href="https://docs.microsoft.com/pt-br/windows/dev-environment/rust/setup">Setup Rust for Windows</a> page, as you may need to install additional dependencies.</p>
<p>In case you want to do small experiments without having to install the language, a good alternative is to use <a href="https://play.rust-lang.org/">the playground</a>, which is an online editor that allows you to compile and run simple code. It's also a good way to share code snippets with other people in case you need help on specific questions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World</a></h1>
<p>It's a tradition, when starting to learn a new programming language, to present a program which consists of showing a <code>hello, world!</code> message on the terminal.</p>
<p>Here we go:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;Hello, World!&quot;);
}
</code></pre></pre>
<p>You can run this code straight from the book. Just click in the &quot;play&quot; button in the top-right corner of the box which contains the code.</p>
<p>Just with this little piece of code it's possible to get in touch with a lot of elements of the language, which we'll see with details later. Don't worry trying to understand them deeply now.</p>
<ul>
<li>The <code>main</code> function defines the execution's entry point. That's where your application's code starts to run.</li>
<li>Blocks are defined with a pair of <code>{</code> and <code>}</code>. Some languages, such as Python, use indentation. Others use keywords such as <code>begin</code> and <code>end</code>.</li>
<li><code>println!</code> is a macro. I can say that because of the <code>!</code> in the end. When your program is compiled, macros are processed for code generation, which is inserted where they've been called. Don't worry about understanding macros now, just know that we'll use some of them before a deeper explanation.</li>
<li><code>&quot;Hello, World!&quot;</code>, in a simplified view, can be seen as a text literal. In Rust, there are a few different types of text (e.g. <code>String</code>, <code>str</code>), each with its use case. It turns out that strings are more complicated than most programmers think, and Rust chose to be explicit about it.</li>
<li><code>println!(&quot;Hello, World!&quot;);</code> is a statement which calls a macro passing a text as argument and has the effect of showing a content in the terminal (with a line break in the end). Statements in Rust end with <code>;</code>. There are expressions too, which are processed at runtime and reduced to a value. For example: <code>2 + 2</code> is reduced to the integer value <code>4</code>.</li>
</ul>
<p>I think that these information are a good start for a &quot;hello, world!&quot;. Now we're starting on the right foot!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>Next, there's a list of a few tools which are very important for the language. Each section title has a link to that tool's documentation, in case you want more specific information.</p>
<h2 id="rustup"><a class="header" href="#rustup"><a href="https://rustup.rs">Rustup</a></a></h2>
<p>Rust's installer. With it you can install and update many language tools. Some of them are described below.</p>
<h2 id="rustc"><a class="header" href="#rustc"><a href="https://doc.rust-lang.org/rustc/index.html">Rustc</a></a></h2>
<p>Language's compiler. Usually, it's not used directly, because <code>cargo</code> simplifies some development-related tasks and deals with the compiler for us.</p>
<h2 id="cargo"><a class="header" href="#cargo"><a href="https://doc.rust-lang.org/cargo/index.html">Cargo</a></a></h2>
<p>Rust's build tool and package manager. It allows to:</p>
<ul>
<li>Create a package with a standardized structure: <code>cargo new &lt;project_name&gt;</code></li>
<li>Perform some development activities:
<ul>
<li>Check if the code compiles: <code>cargo check</code></li>
<li>Run tests: <code>cargo test</code></li>
<li>Compile the code: <code>cargo build</code></li>
<li>Compiled <strong>and</strong> run the code: <code>cargo run</code></li>
</ul>
</li>
<li>Publish a package to be used by other people: <code>cargo publish</code></li>
</ul>
<p>There's many other things which can be done using <code>cargo</code>, but that's a good start.</p>
<h2 id="rustfmt"><a class="header" href="#rustfmt"><a href="https://github.com/rust-lang/rustfmt">Rustfmt</a></a></h2>
<p>Rust's code formatter. Virtually every project uses it. This standardization reduces repetitive work while coding, facilitates the onboarding on new code bases, ends discussions about style... The advantages compensate (by a lot) the freedom's reduction on the code style choice.</p>
<p>To use it, just run <code>cargo fmt</code> and all your project will be formatted.</p>
<h2 id="clippy"><a class="header" href="#clippy"><a href="https://github.com/rust-lang/rust-clippy">Clippy</a></a></h2>
<p>Language's linter, which is basically a tool which analyzes your code and is capable of offering suggestions to try to make it better. Specially in the beginning, <code>cargo clippy</code> can show you more idiomatic ways to write code. Besides that, it can also identify some common programming mistakes.</p>
<h2 id="rustdoc"><a class="header" href="#rustdoc"><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">Rustdoc</a></a></h2>
<p>Rust is known by its ecosystem having above-average documentation and this is due to the excellent documentation generation support we have from <code>rustdoc</code>. By running <code>cargo doc</code>, the documentation from your project and your dependencies are built and everyone has access to them in an standardized way, reducing the weight of this activity and improving the productivity of those who write or read documentation, which is basically everyone.</p>
<h2 id="ide-support"><a class="header" href="#ide-support">IDE Support</a></h2>
<p>A modern language <strong>needs</strong> to have good support to interact with source code. Although Rust is a new language, there are very good projects to offer this support to code editors.</p>
<h3 id="rust-analyzer"><a class="header" href="#rust-analyzer"><a href="https://rust-analyzer.github.io/">Rust-Analyzer</a></a></h3>
<p>It's the Language Server which powers many text editors, like VS Code and Vim. On VS Code, just need to install the <code>rust-lang.rust-analyzer</code> extension to have great support.</p>
<h3 id="intellij-rust"><a class="header" href="#intellij-rust"><a href="https://www.jetbrains.com/pt-br/rust/">Intellij Rust</a></a></h3>
<p>For Intellij-based IDEs, there's a plugin openly developed by JetBrains which brings Rust support for their editors. Just go to the plugins manager and install it to use Rust on Intellij.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-elements"><a class="header" href="#basic-elements">Basic Elements</a></h1>
<p>The elements below, although simple, are an important starting point to code. Most of these concepts are present in other languages.</p>
<h2 id="primitives-types"><a class="header" href="#primitives-types">Primitives Types</a></h2>
<p>This section is non-exhaustive by a matter of simplicity. There are other primitive types beyond these and you may find information about them on the <a href="https://doc.rust-lang.org/std/index.html#primitives">primitive types section in the standard library's documentation</a>.</p>
<h3 id="integers"><a class="header" href="#integers"><strong>Integers</strong></a></h3>
<ul>
<li>Signed: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code> e <code>isize</code>. (<code>i</code> from <em>integer</em>).
<ul>
<li>e.g.: <code>0</code>, <code>-5</code>, <code>1_000_000i32</code></li>
</ul>
</li>
<li>Unsigned: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> e <code>usize</code>.
<ul>
<li>It needs to be non-negative. e.g.: <code>0</code>, <code>10</code>, <code>42</code>, <code>1_000_000usize</code></li>
</ul>
</li>
</ul>
<p>The number in the type indicates how many bits are used by the integer. This has direct relation with the range of values which are possible to represent on that type. For example, <code>u8</code> can only represent a range of 2<sup>8</sup> values.</p>
<p>If the type of the integer literal is not explicitly annotated or cannot be inferred, it will be <code>i32</code> by default.</p>
<h3 id="floats"><a class="header" href="#floats"><strong>Floats</strong></a></h3>
<p><code>f32</code> e <code>f64</code>. Examples: <code>1.0</code>, <code>-15.50f32</code></p>
<p>Floating point numbers can represent decimal numbers (with an impression inherent of the floating point representation in the <em>hardware</em>). <em>Floats</em>, as defined by IEEE-754, can be more a bit more painful to work with than what you're used to in other languages. Rust makes explicit some footguns that could pass unnoticed.</p>
<h3 id="bool"><a class="header" href="#bool"><strong>bool</strong></a></h3>
<p>Can be <code>true</code> or <code>false</code>.</p>
<h3 id="unit"><a class="header" href="#unit">Unit</a></h3>
<p>This is the type of the empty tuple <code>()</code>, which is the only value of this type. It is used in places where there's no meaningful value defined. For example: functions which &quot;return nothing&quot; actually return <code>()</code>.</p>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>A variable stores a value and can be manipulated through its identifier. In Rust, we use <code>let</code> to define variables. <code>let</code> works with pattern matching, but for now we're not going to take advantage of it to keep things simple.</p>
<p>Below there's the skeleton of declaration and binding of variables.</p>
<pre><code class="language-rust ignore">// Declaration
let &lt;identifier&gt;: &lt;type&gt;;

// Declaration with value binding
let &lt;identifier&gt;[: &lt;type&gt;] = &lt;expression&gt;;
</code></pre>
<p>Rust variables are immutable by default. If you try to change an immutable variable's content, the compiler will complain:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If you try to run it, You'll see that this code doesn't compile.
let x = 5;
x = 10;
<span class="boring">}
</span></code></pre></pre>
<p>As our dear compiler suggests, just add <code>mut</code> before the identifier to make the variable mutable.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// It'll work this time!
let mut x = 5;
x = 10;
assert_eq!(x, 10);
<span class="boring">}
</span></code></pre></pre>
<p>It's important to note that Rust has type inference. This means that it tries to identify undeclared types by using the types of the expressions present in the code. For example:</p>
<pre><code class="language-rust ignore">let is_raining = true;
</code></pre>
<p>It's not necessary to annotate the type. As <code>true</code> is of type <code>bool</code>, <code>is_raining</code> will also be.</p>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>A complete list can be found <a href="https://doc.rust-lang.org/book/appendix-02-operators.html">on this Rust Book appendix</a>.</p>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<p><code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code></p>
<p>In case you don't know, <code>%</code> is the division remainder of the first number by the second one.</p>
<p>These operators can be used together with assignment. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 2 + 2;
x += 1;
assert_eq!(x, 5);
<span class="boring">}
</span></code></pre></pre>
<h3 id="logic"><a class="header" href="#logic">Logic</a></h3>
<ul>
<li>Negation: <code>!</code></li>
<li>logic AND: <code>&amp;&amp;</code></li>
<li>logic OR: <code>||</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = true &amp;&amp; !false;
assert_eq!(x, true);
<span class="boring">}
</span></code></pre></pre>
<h3 id="relational"><a class="header" href="#relational">Relational</a></h3>
<p><code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>, <code>&gt;</code></p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5 &lt;= 10;
assert_eq!(x, true);

let y = 3 &lt; 1;
assert_eq!(y, false);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrowing"><a class="header" href="#ownership-and-borrowing">Ownership and Borrowing</a></h1>
<p>If you ask me: &quot;what is Rust's most innovative feature?&quot;, my answer would be <em>ownership</em>. This concept allows the language to be memory-safe without a garbage collector. In practice, you have the performance of a systems language without giving up reliability.</p>
<p>If you came from languages that are not C or C++, it means that now you have a systems language that feels like programming in the high-level. Anyone can write efficient code without the fear of accidentally corrupt the memory.</p>
<p>If by chance you now C or C++, you probably needed to debug a series of errors from manual memory management. You'll be happy to know that <code>rustc</code> simply rejects programs which can cause these errors with helpful, instructive messages, explaining you what could go wrong.</p>
<h2 id="the-concept"><a class="header" href="#the-concept">The Concept</a></h2>
<p>The ownership rules are pretty simple:</p>
<ul>
<li>Every value has a variable which is its owner.</li>
<li>the value's ownership can be moved.</li>
<li>When the owner goes out of the scope, the value is released.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = String::from(&quot;hello&quot;); // x is the owner of the string
    // ...
    println!(&quot;Initially, x is owner of: {x}&quot;);
    // ...
    let y = x; // The string was moved to `y`. `x` stopped being the owner.
    // From this point, trying to access the string through `x` is an invalid operation, since the string was moved.
    // ...
    // println!(&quot;x is owner of: {x}&quot;); // invalid!
    // ...
    println!(&quot;Now, y is owner of: {y}&quot;);
    // ...
    // At the end of this function, `y` goes out of scope and the string will be released.
}
</code></pre></pre>
<p>Besides ownership, we have borrowing:</p>
<ul>
<li>The value's owner can borrow it through shared references (immutable) or unique references (mutable).</li>
<li>At any moment, there can only be one unique reference or any number or any number of shared references.</li>
<li>References are always valid. They can't be used after the value they reference is moved or released.</li>
</ul>
<p>That's it. By following these rules, we are free from any trouble involving allocation and release of resources. <strong>And the best part</strong>: the compiler check if we're following them automatically.</p>
<p>Illustrating with an example:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Book {
    title: String,
}

fn shared(book: &amp;Book) {
    println!(&quot;[shared] The book's title is: {}\n&quot;, book.title);
}

fn unique(book: &amp;mut Book) {
    println!(&quot;[unique] The book's title was: {}&quot;, book.title);
    book.title.push_str(&quot; part 2&quot;);
    println!(&quot;[unique] Now the title is: {}\n&quot;, book.title);
}

fn be_owner(book: Book) {
    println!(&quot;[be_owner] I'm the owner of the book: {}\n&quot;, book.title);
}

fn main() {
    let mut first_owner = Book {
        title: String::from(&quot;How to make friends and influence people&quot;) // recommended
    };

    // Here, we are lending a shared borrow of the book to the variable `first_borrow`
    let first_borrow = &amp;first_owner;

    // We create a second shared reference to pass to the function `shared`
    shared(&amp;first_owner);

    // That's okay if you lend a mutable borrow....
    unique(&amp;mut first_owner);

    // But you cannot access `first_borrow` anymore!
    // println!(&quot;title: {}&quot;, first_borrow.title);

    // But there's no problem to create a new shared reference.
    let second_borrow = &amp;first_owner;

    // The idea is that if you have a shared reference, you cannot access it after it could've been changed (e.g. by a mutable reference or when the value is moved to other owner)

    // Everything okay!
    shared(second_borrow);

    // Ownership moved to other owner.
    let second_owner = first_owner;

    // All the preceding references stopped being valid because of the move. The old owner stopping being accessible too!
    // shared(second_borrow);
    // unique(&amp;mut first_owner);

    println!(&quot;[main] second owner: {}\n&quot;, second_owner.title);

    be_owner(second_owner);

    // The book is not accessible here, since its ownership was passed to the `be_owner` function. At this point, the value has been released. `second_owner` is not accessible too.
    // let invalid_borrow = &amp;second_owner;
}
</code></pre></pre>
<p>Feel free to play with this example. Notice the error messages. They are very descriptive and were made to help you having a better understanding of why a given piece of code is invalid.</p>
<p>All you have seen here affects the whole language. With time, these concepts become natural and you'll start to agree with the borrow checker (part of <code>rustc</code> which checks if you're following the rules) instead of fighting it. I even miss these concepts when I go back to other languages, because it's usually easier to understand what's happening in the source code.</p>
<p>Maybe some people will notice that certain things which cause errors in the <code>Book</code> example are possible with integers and floats. The reason is that these types are cheap to copy. So, instead of moving them, the value is copied. It happens because they implement the trait <code>Copy</code>. We'll talk about traits ahead, but they're similar to interfaces in other languages.</p>
<p>Besides that, I omitted the lifetimes concept in purpose. They are necessary for the compiler to guarantee that the references are always valid. However, it seemed more appropriate to get into this concept after explaining generic code, as a lifetime is a sort of generalization over how long a reference is valid.</p>
<h2 id="what-rustc-protects-you-from"><a class="header" href="#what-rustc-protects-you-from">What <code>rustc</code> protects you from</a></h2>
<p>The following examples are written in C, because it allows to illustrate well how you could cause undefined behavior (UB) in your program, which is basically an elegant way of telling that it can, under any execution, make your application:</p>
<ul>
<li>Abort execution</li>
<li>Run normally</li>
<li>Run, but process invalid values</li>
</ul>
<p>When you got UB, the best to happen is the execution to be aborted as soon as the corruption occurs. This way, you can try to identify where the improper memory use occurred. Nonetheless, it can work on your machine, but not in production. Yeah, very fun.</p>
<p>Personally, I just understood all the memory problems below after learning Rust. Before that, I just stumbled on them without fully understanding the kind of error that was happening on my program. In my C learning, no reference I used taught me about those classes of errors in a clear way.</p>
<h3 id="use-after-free"><a class="header" href="#use-after-free">use after free</a></h3>
<p>It consists in using a memory which you already released to the system. When a memory region is no longer yours, there's no guarantee that you're accessing valid information.</p>
<pre><code class="language-c">void main() {
    int *p = malloc(sizeof(int));
    // ...
    free(p);
    *p = 123; // Writing on a released memory region! UB!
}
</code></pre>
<p>In the best case, you'll get a segmentation fault. In the worst, <code>*p</code>'s content will be overwritten and you'll process garbage, making the execution fails in other part of the code, or even worse: your program may generate and invalid output. I lost two nights of sleep on this kind of error once.</p>
<p>In Rust, it doesn't even compile:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">fn main() {
    let x = String::from(&quot;ferris!&quot;);
    drop(x); // The string's ownership has been moved to `drop`
    // ...
    println!(&quot;{x}&quot;);
}
</code></pre></pre>
<h3 id="double-free"><a class="header" href="#double-free">double free</a></h3>
<p>The same memory address is released twice.</p>
<pre><code class="language-c">void main() {
    void *p = malloc(500);
    // ...
    free(p);
    // ...
    free(p); // Same address released more than once! UB!
}
</code></pre>
<p>It looks improbable to occur, but it can be easy to introduce on a refactor.</p>
<p>In Rust, it doesn't even compile:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">fn main() {
    let x = String::from(&quot;ferris!&quot;);
    drop(x); // The string's ownership has been moved to `drop`
    // ...
    drop(x); // It isn't possible to pass to `drop` (or to any other fn) a value which has been moved.
}
</code></pre></pre>
<h3 id="dereferencing-a-null-pointer"><a class="header" href="#dereferencing-a-null-pointer">Dereferencing a null pointer</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions">The 1 billion dollars mistake</a>. Even high-level languages, with garbage collection, allow this memory error.</p>
<pre><code class="language-c">void main() {
    void *p = malloc(500); // this function may return NULL in case memory hasn't been allocated successfully
    // ...
    *p = 123; // Following a NULL pointer! UB!
}
</code></pre>
<p>The good side of this error is that it normally aborts the execution instead of processing invalid data. The bad side... This is an error class which is totally avoidable, even without ownership. The sooner errors are fixed, lower are the costs. If your tools stop the introduction of certain kinds of defects, that's even better.</p>
<p>In Rust... There's no null reference. We use <code>Option&lt;T&gt;</code> to represent that a value of type <code>T</code> can be present (<code>Some(value)</code>) or not (<code>None</code>).</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x: Option&lt;String&gt; = Some(String::from(&quot;ferris!&quot;));
    // ...
    // I can't access string directly without first checking if `x`, which is a `Option&lt;String&gt;`, is `Some(...)` or `None`.
    match x {
        Some(value) =&gt; println!(&quot;I found this: {value}&quot;),
        None =&gt; println!(&quot;Nothing here!&quot;),
    }
}
</code></pre></pre>
<h3 id="memory-leak"><a class="header" href="#memory-leak">Memory leak</a></h3>
<p>Technically, leaking memory isn't considered UB. However, it consumes system resources unnecessarily.</p>
<pre><code class="language-c">void main() {
    void *p = malloc(500000000);
    // Using p...
    // ...
    // I don't need `p` anymore, but I forgot to `free` it...
    // ...
}
</code></pre>
<p>In Rust, memory will be released automatically once the owner goes out of scope. Even though leaking memory is something safe to do in Rust (i.e. someone could leak memory explicitly if they want/need without using <code>unsafe</code>), most of the time it'll be released automatically due to the ownership concept.</p>
<h3 id="accessing-an-invalid-memory-region"><a class="header" href="#accessing-an-invalid-memory-region">Accessing an invalid memory region</a></h3>
<p>To read or to write information beyond the allocated memory. The memory you accessed isn't yours, so anything can happen.</p>
<pre><code class="language-c">void main() {
    int *p = malloc(10 * sizeof(int));
    p[10] = 42; // I wrote on the 11th position! UB!
}
</code></pre>
<p>Reasonably easy to happen when using arrays.</p>
<p>In Rust, the execution will always be aborted, indicating which code tried to perform an invalid access to memory:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">fn main() {
    let x = vec![1, 2, 3];
    // ...
    let v = x[100_000]; // For sure our `vec` doesn't have all that size
    println!(&quot;An integer from x: {v}&quot;);
}
</code></pre></pre>
<h3 id="manipulate-uninitialized-memory"><a class="header" href="#manipulate-uninitialized-memory">Manipulate uninitialized memory</a></h3>
<p>Uninitialized memory may contain anything. In the best case, the memory will be zeroed. In the worst, you'll read anything that was written there before.</p>
<pre><code class="language-c">void main() {
    int *p;
    // ...
    int x = *p; // Dereferencing `p` without initializing it before! UB!
}
</code></pre>
<p>In Rust, it doesn't even compile:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">fn main() {
    let x: String;
    // Oops, we forgot to initialize...
    println!(&quot;{x}&quot;);
}
</code></pre></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Probably, there's other memory problems that I didn't cover. Fortunately, you'll hardly find them. Yes, it's possible to have UB in Rust if you (or your dependency) uses <em>unsafe</em> incorrectly, but it's very likely that you won't need this language resource to develop your software.</p>
<p>Don't worry about decorating the rules. What is important is to understand what each of them mean. It's the compiler's job to ensure that they are being followed.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
