<!DOCTYPE HTML>
<html lang="pt-br" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F8EYVQDEQP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-F8EYVQDEQP');
</script>        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Guia para orientar pessoas desenvolvedoras no aprendizado de Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">Sobre esse Guia</a></li><li class="chapter-item expanded affix "><li class="part-title">Guia</li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introdução</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/prerequisites.html"><strong aria-hidden="true">1.1.</strong> Pré-requisitos</a></li><li class="chapter-item expanded "><a href="introduction/roadmap.html"><strong aria-hidden="true">1.2.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="introduction/installation.html"><strong aria-hidden="true">1.3.</strong> Instalação</a></li><li class="chapter-item expanded "><a href="introduction/hello_world.html"><strong aria-hidden="true">1.4.</strong> Olá, Mundo!</a></li></ol></li><li class="chapter-item expanded "><a href="tools.html"><strong aria-hidden="true">2.</strong> Ferramentas</a></li><li class="chapter-item expanded "><a href="basic_elements.html"><strong aria-hidden="true">3.</strong> Elementos Básicos</a></li><li class="chapter-item expanded "><a href="structured_programming/index.html"><strong aria-hidden="true">4.</strong> Programação Estruturada</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="structured_programming/sequence.html"><strong aria-hidden="true">4.1.</strong> Sequência</a></li><li class="chapter-item expanded "><a href="structured_programming/decision.html"><strong aria-hidden="true">4.2.</strong> Decisão</a></li><li class="chapter-item expanded "><a href="structured_programming/repetition.html"><strong aria-hidden="true">4.3.</strong> Repetição</a></li><li class="chapter-item expanded "><a href="structured_programming/functions.html"><strong aria-hidden="true">4.4.</strong> Funções</a></li></ol></li><li class="chapter-item expanded "><a href="ownership_and_borrowing.html"><strong aria-hidden="true">5.</strong> Propriedade e Empréstimo</a></li><li class="chapter-item expanded "><a href="types_and_traits.html"><strong aria-hidden="true">6.</strong> Tipos e Traits</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">7.</strong> Código Genérico</a></li><li class="chapter-item expanded "><a href="project_structure.html"><strong aria-hidden="true">8.</strong> Estrutura de um Projeto</a></li><li class="chapter-item expanded "><a href="functional_programming.html"><strong aria-hidden="true">9.</strong> Programação Funcional</a></li><li class="chapter-item expanded affix "><li class="part-title">Tópicos Avançados</li><li class="chapter-item expanded "><a href="advanced_topics.html"><strong aria-hidden="true">10.</strong> Tópicos Avançados</a></li><li class="chapter-item expanded affix "><li class="part-title">Projetos de Treino</li><li class="chapter-item expanded "><a href="training_projects.html"><strong aria-hidden="true">11.</strong> Projetos de Treino</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dbofmmbt/guia-para-entender-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="guia-para-entender-rust"><a class="header" href="#guia-para-entender-rust">Guia para Entender Rust</a></h1>
<!-- TODO inserir imagem -->
<p>Rust é uma linguagem de programação muito bem pensada. Ela busca reunir diversos conceitos desenvolvidos por outras linguagens, indústria e academia de modo a construir uma linguagem sólida para desenvolver soluções eficientes e confiáveis de forma produtiva.</p>
<p>No entanto, ela ganhou uma fama de ser uma linguagem com uma curva de aprendizado alta. Não vou te enganar: Rust possui muitos recursos para te ajudar, mas você precisa entender como eles funcionam antes. O que posso te dizer é que, no geral, cada escolha feita por essa linguagem tem um propósito. Quando você entende os motivos, algo que antes parecia complicado pode se tornar compreensível.</p>
<p>Se você pretende desenvolver uma aplicação com alto grau de processamento concorrente, provavelmente precisará aprender sobre os recursos de programação assíncrona (<code>async/await</code>). Caso você lide diretamente com <em>hardware</em> em programação embarcada, talvez precise usar <code>unsafe</code> ao interagir com
recursos nativos do dispositivo em questão. Ao desenvolver uma biblioteca, pode parecer interessante implementar macros para criar uma interface mais conveniente.</p>
<p>Saiba que você não precisa aprender tudo de uma vez, nem ser especialista em todos os recursos da linguagem. Cada um pode focar nos recursos que são relevantes para a ferramenta que deseja desenvolver.
Não pense que você precisa absorver tudo de uma vez só, pois ninguém deveria precisar.</p>
<p>O que proponho aqui é o entendimento da linguagem. Existe um núcleo de conceitos os quais toda pessoa desenvolvedora precisa saber para dominá-la, não importa o tipo de aplicação que ela faça. É esse núcleo que busco ensinar nesse curso.</p>
<p>Além disso, vou apresentar esses conceitos de forma pouco usual. Dificilmente você vai encontrar um material que siga essa ordem. Cada tópico é cuidadosamente pensado para que seja embasado nos tópicos anteriores, formando um aprendizado em camadas. Você não tentaria construir o segundo andar de um prédio sem antes construir o primeiro andar, certo?</p>
<p>Qualquer conceito ou detalhamento que eu considere fora do escopo do guia terá referências para conteúdos de alta qualidade, de modo a complementar esse guia.</p>
<!-- TODO gancho para a próxima seção -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="introdução"><a class="header" href="#introdução">Introdução</a></h1>
<p>Comece por aqui. A ideia da introdução é te preparar para o restante do guia.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pré-requisitos"><a class="header" href="#pré-requisitos">Pré-requisitos</a></h1>
<p>De forma geral, eu assumo que a pessoa leitora sabe programar em alguma linguagem, mesmo que apenas o básico. Se eu fosse fazer um guia para iniciar alguém a programar do zero (e pretendo fazer um dia!) eu explicaria diversos conceitos do funcionamento de computadores e de paradigmas de programação, e isso tomaria tempo para escrever bem. Se você não souber programar e quiser seguir o guia mesmo assim, lembre-se de ir com calma e buscar informações adicionais na internet quando sentir necessidade.</p>
<p>Outro requisito importante é o alinhamento com a minha proposta. Meu foco é no entendimento dos conceitos. Em <em>software</em>, entender o que você está fazendo pode ser a diferença entre resolver um problema em minutos ou em dias. Vão surgir exemplos e exercícios ao longo do guia, mas meu foco sempre é conceitual.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<!-- TODO montar roadmap -->
<p>A ideia dessa página é descrever o roteiro do guia. Explicando de forma sucinta cada seção. Como o guia ainda está no começo, vou deixar para fazer isso depois.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instalação"><a class="header" href="#instalação">Instalação</a></h1>
<p>A forma mais recomendada para a instalação é através da ferramenta <code>rustup</code>, que cuida de instalações e atualizações dos componentes básicos da linguagem, como o <code>rustc</code>, <code>cargo</code> e <code>clippy</code>.</p>
<p>Se você decidiu instalar a linguagem na sua máquina, basta seguir as instruções no site do <a href="https://rustup.rs">rustup</a> que deve dar tudo certo. Caso você use Windows, recomendo dar uma olhada nessa página de <a href="https://docs.microsoft.com/pt-br/windows/dev-environment/rust/setup">setup da linguagem Rust no Windows</a>, da Microsoft, pois talvez você precise instalar dependências adicionais.</p>
<p>Caso você queira fazer pequenos experimentos sem ter que instalar a linguagem, uma boa alternativa é o uso do <a href="https://play.rust-lang.org/">playground</a>, que é um editor online que permite compilar e rodar códigos simples. Ele é bom também para compartilhar trechos de código com outras pessoas para tirar dúvidas específicas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="olá-mundo"><a class="header" href="#olá-mundo">Olá, Mundo</a></h1>
<p>É uma tradição, ao aprender uma linguagem de programação nova, a apresentação do <code>hello, world!</code> da linguagem, que consiste em exibir uma mensagem no terminal com os dizeres &quot;Olá, Mundo!&quot;.</p>
<p>Então vamos lá:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;Olá, Mundo!&quot;);
}
</code></pre></pre>
<p>Você pode rodar esse código direto do guia. Basta clicar no botão &quot;play&quot; no canto superior direito da caixa que contém o código.</p>
<p>Só com esse pequeno trecho de código já é possível ter contato com vários elementos da linguagem, que vamos ver com detalhes posteriormente. Não se preocupe em entendê-los a fundo agora.</p>
<ul>
<li>A função <code>main</code> que define o ponto de entrada da execução. É onde o código da sua aplicação começa a rodar.</li>
<li>Blocos são definidos com um par de <code>{</code> e <code>}</code>. Algumas linguagens, como Python, usam identação. Outras usam palavras-chave como <code>begin</code> e <code>end</code>.</li>
<li><code>println!</code> é uma macro. Posso dizer isso por conta do <code>!</code> no final. No momento da compilação, as macros são processadas para geração de código, que é inserido no local onde foram chamadas. Não se preocupe em entender macros agora, só saiba que usaremos algumas antes de uma explicação mais aprofundada.</li>
<li><code>&quot;Olá, Mundo!&quot;</code>, falando de forma bem simplificada, pode ser entendida como um literal de texto. Em Rust, existem alguns tipos diferentes de texto (e.g. <code>String</code>, <code>str</code>) e mais para frente vai ficar claro o porquê.</li>
<li><code>println!(&quot;Olá, Mundo!&quot;);</code> é uma declaração que chama uma macro passando um texto como argumento e tem como efeito exibir um conteúdo no terminal (com quebra de linha). Declarações em Rust terminam com <code>;</code>. Existem também as expressões, que são processadas em tempo de execução e são reduzidas a um valor. Por exemplo: <code>2 + 2</code> é reduzido para o valor inteiro <code>4</code>.</li>
</ul>
<p>Acho que essas informações já são um bom começo para um &quot;Hello, world!&quot;. Agora sim começamos com o pé direito!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ferramentas"><a class="header" href="#ferramentas">Ferramentas</a></h1>
<p>A seguir, temos uma lista com algumas das ferramentas que são muito importantes para a linguagem. Cada título de seção possui um link para a documentação da ferramenta em questão, caso você queira informações mais específicas.</p>
<h2 id="rustup"><a class="header" href="#rustup"><a href="https://rustup.rs">Rustup</a></a></h2>
<p>É o instalador do Rust. Com ele você consegue instalar e atualizar diversos componentes da linguagem. Alguns deles são descritos abaixo.</p>
<h2 id="rustc"><a class="header" href="#rustc"><a href="https://doc.rust-lang.org/rustc/index.html">Rustc</a></a></h2>
<p>Esse é o compilador da linguagem. Normalmente ele não é utilizado diretamente, pois o Cargo simplifica diversas tarefas no desenvolvimento e lida com o compilador por nós.</p>
<h2 id="cargo"><a class="header" href="#cargo"><a href="https://doc.rust-lang.org/cargo/index.html">Cargo</a></a></h2>
<p>É o gerenciador de pacotes do Rust. Ele permite:</p>
<ul>
<li>Criar um pacote com uma estrutura padronizada: <code>cargo new &lt;nome_do_projeto&gt;</code></li>
<li>Realizar diversas atividades de desenvolvimento:
<ul>
<li>Checar se o código compila: <code>cargo check</code></li>
<li>Rodar testes: <code>cargo test</code></li>
<li>Compilar o código: <code>cargo build</code></li>
<li>Compilar <strong>e</strong> rodar o código: <code>cargo run</code></li>
</ul>
</li>
<li>Publicar um pacote para ser usado por outras pessoas: <code>cargo publish</code></li>
</ul>
<p>Tem muitas outras coisas que podem ser feitas através do cargo, mas esse já é um bom começo.</p>
<h2 id="rustfmt"><a class="header" href="#rustfmt"><a href="https://github.com/rust-lang/rustfmt">Rustfmt</a></a></h2>
<p>É o formatador de código da linguagem. Praticamente todo projeto utiliza ele. Essa padronização diminui trabalho manual ao programar, facilita a entrada em bases de código novas, elimina discussões sobre estilo... As vantagens compensam (e muito) a redução de liberdade no estilo do código.</p>
<p>Para utilizá-lo, basta rodar <code>cargo fmt</code> e todo o seu projeto será ajustado.</p>
<h2 id="clippy"><a class="header" href="#clippy"><a href="https://github.com/rust-lang/rust-clippy">Clippy</a></a></h2>
<p>É o <em>linter</em> da linguagem, que é basicamente uma ferramenta que analisa seu código e é capaz de oferecer sugestões para tentar torná-lo melhor. Principalmente ao começar na linguagem, <code>cargo clippy</code> pode te mostrar formas mais idiomáticas na escrita do código, além de identificar erros de programação comuns.</p>
<h2 id="rustdoc"><a class="header" href="#rustdoc"><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">Rustdoc</a></a></h2>
<p>Rust é reconhecida por seu ecossistema ter uma documentação acima da média e isso é fruto de um excelente suporte à geração de documentação através do <code>rustdoc</code>. Ao rodar <code>cargo doc</code>, a documentação do seu projeto e de suas dependências são construídas e todos têm acesso a uma forma padronizada de documentação, reduzindo o peso da atividade e aumentando a produtividade de quem desenvolve e depende de pacotes de outras pessoas.</p>
<h2 id="suporte-de-ide"><a class="header" href="#suporte-de-ide">Suporte de IDE</a></h2>
<p>Uma linguagem moderna <strong>precisa</strong> ter um suporte adequado para a interação com o código fonte. Embora Rust seja uma linguagem nova, já existem projetos muito bons para oferecer esse suporte a vários editores.</p>
<h3 id="rust-analyzer"><a class="header" href="#rust-analyzer"><a href="https://rust-analyzer.github.io/">Rust-Analyzer</a></a></h3>
<p>É o servidor de linguagem que alimenta vários editores de texto, como VS Code e Vim. No VS Code, basta instalar a extensão <code>rust-analyzer</code> para ter o suporte.</p>
<h3 id="intellij-rust"><a class="header" href="#intellij-rust"><a href="https://www.jetbrains.com/pt-br/rust/">Intellij Rust</a></a></h3>
<p>Para as IDEs baseadas no Intellij, existe um plugin desenvolvido abertamente pela JetBrains que traz suporte a Rust aos seus editores. Basta instalar o plugin e contar com suporte na sua IDE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elementos-básicos"><a class="header" href="#elementos-básicos">Elementos Básicos</a></h1>
<p>Os elementos abaixo, embora simples, são um ponto de partida importante para programar. A maioria desses conceitos estão presentes em outras linguagens.</p>
<h2 id="tipos-primitivos"><a class="header" href="#tipos-primitivos">Tipos primitivos</a></h2>
<p>Essa seção não é exaustiva por questões de simplicidade. Existem outros tipos primitivos além desses e você pode descobrir sobre todos na <a href="https://doc.rust-lang.org/std/index.html#primitives">seção de tipos primitivos da documentação da linguagem</a>.</p>
<h3 id="inteiros"><a class="header" href="#inteiros"><strong>Inteiros</strong></a></h3>
<ul>
<li>Com sinal: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code> e <code>isize</code>. (<code>i</code> de <em>integer</em>).
<ul>
<li>e.g.: <code>0</code>, <code>-5</code>, <code>1_000_000i32</code></li>
</ul>
</li>
<li>Sem sinal: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> e <code>usize</code>. (<code>u</code> de <em>unsigned</em>, sem sinal).
<ul>
<li>e.g.: <code>10</code>, <code>42</code>, <code>1_000_000usize</code></li>
</ul>
</li>
</ul>
<p>O número no tipo representa quantos bits são usados pelo inteiro. Isso tem relação direta com o intervalo de valores que são possíveis de representar. Por exemplo, <code>u8</code> consegue representar um intervalo de 2<sup>8</sup> valores.</p>
<h3 id="floats"><a class="header" href="#floats"><strong>Floats</strong></a></h3>
<p><code>f32</code> e <code>f64</code>. Exemplos: <code>1.0</code>, <code>-15.50f32</code></p>
<p>Números flutuantes permitem representar números decimais (com uma imprecisão inerente da representação de ponto flutuante no <em>hardware</em>). <em>Floats</em>, conforme o padrão IEEE-754, podem ser um pouco mais trabalhosos de lidar do que você estava acostumado em outras linguagens. Rust deixa explícito possíveis tiros no pé que poderiam passar despercebidos.</p>
<h3 id="bool"><a class="header" href="#bool"><strong>bool</strong></a></h3>
<p>Pode assumir os valores <code>true</code> e <code>false</code>.</p>
<h3 id="unit"><a class="header" href="#unit">Unit</a></h3>
<p>Esse é o tipo do <code>()</code>, que é o único valor desse tipo. Ele é usado em locais em que não há um valor significativo definido. Por exemplo: funções que &quot;não retornam nada&quot; na verdade retornam <code>()</code>.</p>
<h2 id="variáveis"><a class="header" href="#variáveis">Variáveis</a></h2>
<p>Uma variável guarda um valor e ela pode ser manipulada através de seu identificador. Em Rust, utilizamos o <code>let</code> para definir variáveis. <code>let</code> trabalha com casamento de padrões, mas por enquanto não iremos tirar proveito desse recurso para manter as coisas simples.</p>
<p>Abaixo segue o esqueleto de declaração e associação (<em>binding</em>) de uma variável.</p>
<pre><code class="language-rust ignore">// Declaração
let &lt;identificador&gt;: &lt;tipo&gt;;

// Declaração com associação de valor
let &lt;identificador&gt;[: &lt;tipo&gt;] = &lt;expressão&gt;;
</code></pre>
<p>As variáveis em Rust são imutáveis por padrão. Caso você tente mudar o conteúdo de uma variável imutável, o compilador reclamará:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Se você tentar rodar, verá que esse código não compila.
let x = 5;
x = 10;
<span class="boring">}
</span></code></pre></pre>
<p>Como nosso querido compilador sugere, basta adicionar <code>mut</code> antes do identificador para tornar a variável mutável.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Agora vai!
let mut x = 5;
x = 10;
assert_eq!(x, 10);
<span class="boring">}
</span></code></pre></pre>
<p>É importante notar que Rust possui inferência de tipos. Isto é, ela tenta identificar tipos não declarados através dos tipos das expressões utilizadas no código. Por exemplo:</p>
<pre><code class="language-rust ignore">let is_raining = true;
</code></pre>
<p>Não é obrigatório anotar o tipo. Já que <code>true</code> é do tipo <code>bool</code>, <code>is_raining</code> também vai ser.</p>
<h2 id="operadores"><a class="header" href="#operadores">Operadores</a></h2>
<p>Uma lista completa pode ser encontrada <a href="https://doc.rust-lang.org/book/appendix-02-operators.html">neste apêndice do livro do Rust</a>.</p>
<h3 id="aritméticos"><a class="header" href="#aritméticos">Aritméticos</a></h3>
<p><code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code></p>
<p>Caso você não conheça, <code>%</code> é o resto de divisão do primeiro número pelo segundo.</p>
<p>Esses operadores podem ser usados em conjunto com atribuição. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 2 + 2;
x += 1;
assert_eq!(x, 5);
<span class="boring">}
</span></code></pre></pre>
<h3 id="lógicos"><a class="header" href="#lógicos">Lógicos</a></h3>
<ul>
<li>Negação:<code>!</code></li>
<li>E lógico: <code>&amp;&amp;</code></li>
<li>OU lógico: <code>||</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = true &amp;&amp; !false;
assert_eq!(x, true);
<span class="boring">}
</span></code></pre></pre>
<h3 id="relacionais"><a class="header" href="#relacionais">Relacionais</a></h3>
<p><code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>, <code>&gt;</code></p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5 &lt;= 10;
assert_eq!(x, true);

let y = 3 &lt; 1;
assert_eq!(y, false);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programação-estruturada"><a class="header" href="#programação-estruturada">Programação Estruturada</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequência"><a class="header" href="#sequência">Sequência</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decisão"><a class="header" href="#decisão">Decisão</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repetição"><a class="header" href="#repetição">Repetição</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funções"><a class="header" href="#funções">Funções</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="propriedade-e-empréstimo"><a class="header" href="#propriedade-e-empréstimo">Propriedade e Empréstimo</a></h1>
<p>Se você me perguntar: &quot;qual é a coisa mais inovadora de Rust?&quot;, minha resposta é <em>ownership</em>. Esse conceito permite que a linguagem seja <em>memory-safe</em> sem coletor de lixo. Na prática, você tem o desempenho de uma linguagem de sistemas sem abrir mão da confiabilidade.</p>
<p>Se você veio de linguagens que não sejam C ou C++, isso quer dizer que agora você tem uma linguagem de sistemas que te dá passa a sensação de programar em alto nível. Qualquer um pode escrever código eficiente sem medo de acidentalmente corromper a memória.</p>
<p>Se por acaso você conhece C e C++, você provavelmente já precisou debuggar uma série de erros provenientes do gerenciamento manual de memória. Ficará feliz em saber que o <code>rustc</code> simplesmente rejeita programas que podem causar esses erros, com mensagens de erro instrutivas, te explicando o que poderia ocorrer de errado.</p>
<h2 id="o-conceito"><a class="header" href="#o-conceito">O Conceito</a></h2>
<p>As regras de propriedade são bem simples:</p>
<ul>
<li>Todo valor tem uma única variável que é sua dona.</li>
<li>A propriedade do valor pode ser movida.</li>
<li>Quando a dona sai de escopo, o valor é liberado.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = String::from(&quot;hello&quot;); // x é dona da string
    // ...
    println!(&quot;Inicialmente, x é dona de: {x}&quot;);
    // ...
    let y = x; // a string foi movida para `y`. `x` deixou de ser dona.
    // A partir desse ponto, tentar acessar a string através de `x` é uma operação inválida, já que a string foi movida.
    // ...
    // println!(&quot;x é dona de: {x}&quot;); // inválido!
    // ...
    println!(&quot;Agora, y é dona de: {y}&quot;);
    // ...
    // Ao final dessa função, `y` sai de escopo e a string vai ser liberada.
}
</code></pre></pre>
<p>Além da propriedade, temos o empréstimo:</p>
<ul>
<li>O dono de um valor pode emprestá-lo através de referências compartilhadas (imutáveis) ou únicas (mutáveis).</li>
<li>A qualquer momento, só pode haver uma referência única ou qualquer número de referências compartilhadas.</li>
<li>Referências são sempre válidas. Elas não podem ser utilizadas após o valor que referenciam ser movido ou liberado.</li>
</ul>
<p>É isso. Ao respeitar essas regras, estamos livres de qualquer problema envolvendo alocação e liberação de recursos. <strong>E a melhor parte</strong>: o compilador checa se estamos respeitando essas regras automaticamente.</p>
<p>Ilustrando com um exemplo:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Book {
    title: String,
}

fn shared(book: &amp;Book) {
    println!(&quot;[shared] O título do livro é: {}\n&quot;, book.title);
}

fn unique(book: &amp;mut Book) {
    println!(&quot;[unique] O título do livro era: {}&quot;, book.title);
    book.title.push_str(&quot; parte 2&quot;);
    println!(&quot;[unique] Agora o título é: {}\n&quot;, book.title);
}

fn be_owner(book: Book) {
    println!(&quot;[be_owner] Sou dono do livro: {}\n&quot;, book.title);
}

fn main() {
    let mut first_owner = Book {
        title: String::from(&quot;Como fazer amigos e influenciar pessoas&quot;) // recomendo
    };

    // Aqui estamos concedendo um empréstimo compartilhado do livro para a variável `first_borrow`
    let first_borrow = &amp;first_owner;

    // Criamos uma segunda referência compartilhada para passar para a função `shared`
    shared(&amp;first_owner);

    // Tudo bem você fazer um empréstimo mutável...
    unique(&amp;mut first_owner);

    // Mas você não pode mais acessar `first_borrow`!
    // println!(&quot;titulo: {}&quot;, first_borrow.title);

    // Mas não tem problema você criar uma nova referência compartilhada.
    let second_borrow = &amp;first_owner;

    // A ideia é que se você tem uma referência compartilhada, você não pode acessar o conteúdo dela caso ele possa ter sido alterado (i.e. por uma referência única ou quando o valor é movido de dono)

    // Tudo okay!
    shared(second_borrow);

    // Propriedade movida para um novo dono.
    let second_owner = first_owner;

    // Todas as referências anteriores deixam de ser válidas por conta do movimento. O antigo dono deixa de ser acessível também!
    // shared(second_borrow);
    // unique(&amp;mut first_owner);

    println!(&quot;[main] segundo dono: {}\n&quot;, second_owner.title);

    be_owner(second_owner);

    // O livro não é mais acessível aqui, já que sua propriedade foi passada para a função `be_owner`. Nesse ponto, o valor já foi liberado. `second_owner` também não é mais acessível.
    // let invalid_borrow = &amp;second_owner;
}
</code></pre></pre>
<p>Fique à vontade para brincar com esse exemplo. Repare nas mensagens de erro. Elas são bem descritivas e foram feitas para te ajudar a ter uma melhor compreensão do porquê determinada operação é inválida.</p>
<p>Tudo que você viu aqui permeia a linguagem inteiramente. Com o tempo, esses conceitos ficam naturais e você começa a concordar com o <em>borrow checker</em> (parte do <code>rustc</code> que checa se você está respeitando as regras) em vez de lutar com ele. Dá até falta desses conceitos quando volto para outras linguagens, pois é mais fácil entender o que está acontecendo no programa.</p>
<p>Talvez algumas pessoas reparem que certas coisas que causam erro no exemplo do <code>Book</code> são possíveis com inteiros e <em>floats</em>. A razão disso é que esses tipos são baratos de copiar. Então, em vez de mover o valor, ele é copiado. Isso acontece, pois eles implementam a <em>trait</em> <code>Copy</code>. Vamos conversar sobre <em>traits</em> mais adiante.</p>
<p>Além disso, eu propositalmente omiti o conceito de <em>lifetimes</em>. Eles são necessários para o compilador garantir que as referências são sempre válidas. Me pareceu mais apropriado abordar esse conceito após explicar código genérico, já que o <em>lifetime</em> é uma generalização do tempo de vida de um valor.</p>
<h2 id="do-que-o-rustc-te-protege"><a class="header" href="#do-que-o-rustc-te-protege">Do que o <code>rustc</code> te protege</a></h2>
<p>Os exemplos a seguir são em C, pois ela permite ilustrar bem como você pode causar comportamento indefinido (UB) no seu programa, que é basicamente uma forma elegante de dizer que ele pode, em qualquer execução da sua aplicação, fazer com que ela:</p>
<ul>
<li>Aborte a execução</li>
<li>Funcione normalmente</li>
<li>Funcione, mas processe valores inválidos</li>
</ul>
<p>Quando você tem UB, o melhor que pode acontecer é a execução ser abortada assim que a corrupção ocorre. Assim você pode tentar identificar onde ocorreu o uso indevido de memória e corrigir o problema. Entretanto, pode funcionar na sua máquina, mas em produção não. É, bem divertido.</p>
<p>Particularmente, eu só entendi todos os problemas de memória abaixo quando aprendi Rust. Antes eu esbarrava neles sem saber de fato que tipo de erro estava ocorrendo. No meu aprendizado de C, nenhuma referência que usei me ensinou sobre essas classes de erros de forma clara.</p>
<h3 id="use-after-free"><a class="header" href="#use-after-free"><em>use after free</em></a></h3>
<p>Consiste em usar uma memória que você já liberou para o sistema. Quando uma região de memória deixa de ser sua, não há garantia que você está acessando uma informação válida.</p>
<pre><code class="language-c">void main() {
    void *p = malloc(500);
    // ...
    free(p);
    *p = 123; // Escrita em uma região de memória liberada! UB!
}
</code></pre>
<p>No melhor dos casos, você vai tomar um <em>segmentation fault</em>. No pior, o conteudo de <code>*p</code> vai ser sobrescrito e você vai processar lixo, fazendo a execução dar erro em outra parte do código, ou pior: seu programa vai gerar um <em>output</em> inválido. Perdi duas noites de sono nesse tipo de erro uma vez.</p>
<p>Em Rust, nem compila:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">fn main() {
    let x = String::from(&quot;ferris!&quot;);
    drop(x); // A propriedade da string foi movida para `drop`
    // ...
    println!(&quot;{x}&quot;);
}
</code></pre></pre>
<h3 id="double-free"><a class="header" href="#double-free"><em>double free</em></a></h3>
<p>O mesmo endereço de memória é liberado duas vezes.</p>
<pre><code class="language-c">void main() {
    void *p = malloc(500);
    // ...
    free(p);
    // ...
    free(p); // Mesmo endereço de memória liberado mais de uma vez! UB!
}
</code></pre>
<p>Parece improvável de ocorrer, mas em uma refatoração pode ser fácil de introduzir.</p>
<p>Em Rust, nem compila:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">fn main() {
    let x = String::from(&quot;ferris!&quot;);
    drop(x); // A propriedade da string foi movida para `drop`
    // ...
    drop(x); // Não dá pra passar para `drop` (ou qualquer fn) um valor que foi movido.
}
</code></pre></pre>
<h3 id="dereferenciar-ponteiro-nulo"><a class="header" href="#dereferenciar-ponteiro-nulo">dereferenciar ponteiro nulo</a></h3>
<p>O <a href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions">erro de 1 bilhão de dólares</a>. Até linguagens de alto nível, com coletor de lixo, cometem.</p>
<pre><code class="language-c">void main() {
    void *p = malloc(500); // essa função pode retornar NULL caso a memória não tenha sido alocada com sucesso
    // ...
    *p = 123; // Escrita em NULL! UB!
}
</code></pre>
<p>O lado bom desse erro é que ele normalmente aborta a execução em vez de processar dados inválidos. O lado ruim... essa é uma classe de erros totalmente evitável, mesmo sem <em>ownership</em>. Quanto mais cedo erros são corrigidos, menores são os custos. Se suas ferramentas impedem a introdução de certos tipos de defeitos, melhor ainda.</p>
<p>Em Rust... Não existe referência nula. Nós usamos <code>Option&lt;T&gt;</code> para representar um valor do tipo <code>T</code> que pode estar presente (<code>Some(value)</code>) ou não (<code>None</code>).</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x: Option&lt;String&gt; = Some(String::from(&quot;ferris!&quot;));
    // ...
    // Não posso acessar a string diretamente sem antes checar se `x`, que é uma `Option&lt;String&gt;` é `Some(...)` ou `None`.
    match x {
        Some(value) =&gt; println!(&quot;{value}&quot;),
        None =&gt; println!(&quot;Nada aqui!&quot;),
    }
}
</code></pre></pre>
<h3 id="vazamento-de-memória"><a class="header" href="#vazamento-de-memória">Vazamento de Memória</a></h3>
<p>Tecnicamente, vazar memória não é considerado UB. Entretanto, isso consome recursos do sistema desnecessariamente.</p>
<pre><code class="language-c">void main() {
    void *p = malloc(500000000);
    // Usando p...
    // ...
    // Não preciso mais de p, mas não liberei...
    // ...
}
</code></pre>
<p>Em Rust, a memória será liberada automaticamente quando o dono sai de escopo. Mesmo que vazar memória seja algo seguro de se fazer em Rust (i.e. alguém pode vazar memória explicitamente se quiser/precisar sem usar <code>unsafe</code>), a maior parte do tempo ela vai ser liberada por conta do conceito de propriedade.</p>
<h3 id="acessar-uma-região-de-memória-inválida"><a class="header" href="#acessar-uma-região-de-memória-inválida">Acessar uma região de memória inválida</a></h3>
<p>Ler ou escrever informações fora dos limites da memória que você alocou. A memória que você acessou não é sua, então qualquer coisa pode acontecer.</p>
<pre><code class="language-c">void main() {
    int *p = malloc(10 * sizeof(int));
    p[10] = 42; // Escrevi na décima primeira posição! UB!
}
</code></pre>
<p>Bem fácil de ocorrer com o uso de vetores.</p>
<p>Em Rust, a execução sempre vai ser abortada, indicando onde ocorreu o acesso inválido à memória:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">fn main() {
    let x = vec![1, 2, 3];
    // ...
    let v = x[100_000]; // Com certeza nosso vetor não tem esse tamanho todo
    println!(&quot;Um inteiro de x: {v}&quot;);
}
</code></pre></pre>
<h3 id="manipular-memória-não-inicializada"><a class="header" href="#manipular-memória-não-inicializada">Manipular memória não inicializada</a></h3>
<p>Memória não inicializada pode conter qualquer coisa. No melhor dos casos o conteúdo vai estar zerado. No pior, você vai ler qualquer coisa.</p>
<pre><code class="language-c">void main() {
    int *p;
    // ...
    int x = *p; // Dereferenciado p sem iniciazá-lo! UB!
}
</code></pre>
<p>Em Rust, nem compila:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">fn main() {
    let x: String;
    // Oops, esquecemos de inicializar...
    println!(&quot;{x}&quot;);
}
</code></pre></pre>
<h2 id="conclusão"><a class="header" href="#conclusão">Conclusão</a></h2>
<p>Provavelmente existem outros problemas de memória que eu não abordei. Felizmente, você dificilmente vai encontrá-los. Sim, é possível ter UB em Rust se você (ou sua dependência) usar <em>unsafe</em> incorretamente, mas é bastante provável que você não vai precisar desse recurso da linguagem.</p>
<p>Não se preocupe em decorar as regras. O importante é entender o que cada uma delas significa. É trabalho do compilador garantir que elas estão sendo respeitadas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-e-traits"><a class="header" href="#tipos-e-traits">Tipos e Traits</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="código-genérico"><a class="header" href="#código-genérico">Código Genérico</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estrutura-de-um-projeto"><a class="header" href="#estrutura-de-um-projeto">Estrutura de um projeto</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programação-funcional"><a class="header" href="#programação-funcional">Programação Funcional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tópicos-avançados"><a class="header" href="#tópicos-avançados">Tópicos Avançados</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projetos-de-treino"><a class="header" href="#projetos-de-treino">Projetos de Treino</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
